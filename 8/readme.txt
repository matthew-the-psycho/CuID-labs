Было получено разрешение на исполнение внедрения информации не в .bmp-файл,
    а в .wav-файл.
\\ При условии объяснения механики внедрения / "распаковки" информации.

Реализовано :: 
main.cpp ::
<.exe/.elf> <.wav> <file to enload via / to be enloaded> <--code or --decode>

При флаге --code ::
\\  Будет создан .wav-файл с префиксом ENC_ по argv[1]
При флаге --decode ::
\\  Будет создан файл с указанным форматом в argv[2]

Дополнительно для анализа заголовков был реализован ::
shoe_wav_header.cpp ::
<.exe/.elf> <.wav>
Который оставляет .log в HEX-формате, содержащий заголовок соответствующего файла.

Реализация упаковки и запаковки информации ::
--code ::
    1. Проверка на вместимость файла к упаковке
    2. Вычисление FREQER'а (Показателя глубины кодировки 8/16/32 бит)
    3. LSB-внедрение на 1 Sample (Зависимость от FREQER'а, то есть от глубины кодировки 8/16/32 бит)

--decode ::
    1. Вычисление FREQER'а (Показателя глубины кодировки 8/16/32 бит)
    2. LSB-распаковка из 1 Sample'а (Зависимость от FREQER'а, то есть от глубины кодировки 8/16/32 бит)
\\FREQER, по сути, задаёт границу Sample'а, чтобы не произошло изменения бита в середине полибайтного Sample'а (S16/S32).

Особенность реализации :: 
    После того, как закончится файл для внедрения есть 2 исхода действий с обрабатываемым файлом:
    1. Оставлять всё как есть;
    2. Key_byte = 0x00;
    Был выбран второй вариант. 
    В любом случае в конце DEC_файла было бы одно из двух:
    1. Неосмысленный текст после распакованного;
    2. Сплошные 0х00 после распакованного текста.
    В данном случае наблюдается второе явление.